////////////////////////////////////////////////////////////////////////
// Class:       PandoraLEEAnalyzer
// Module Type: analyzer
// File:        PandoraLEEAnalyzer.h
//
////////////////////////////////////////////////////////////////////////


#ifndef PANDORA_LEE_H
#define PANDORA_LEE_H

#include <math.h>
#include <fstream>
#include <algorithm>
#include <functional>

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// uncomment the lines below as you use these objects

#include "TFile.h"
#include "TH1F.h"
#include "THStack.h"
#include "TTree.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Utilities/InputTag.h"
#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SummaryData/POTSummary.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "uboone/EventWeight/MCEventWeight.h"
#include "larevt/SpaceChargeServices/SpaceChargeService.h"
#include "uboone/UBXSec/DataTypes/SelectionResult.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "TEfficiency.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include "ElectronEventSelectionAlg.h"

#include "EnergyHelper.h"
#include "GeometryHelper.h"

#include "larcore/Geometry/WireGeo.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "uboone/EventWeight/EventWeightTreeUtility.h"

    namespace lee {

class PandoraLEEAnalyzer : public art::EDAnalyzer {
public:
  explicit PandoraLEEAnalyzer(fhicl::ParameterSet const &pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  virtual ~PandoraLEEAnalyzer();

  // Plugins should not be copied or assigned.
  PandoraLEEAnalyzer(PandoraLEEAnalyzer const &) = delete;
  PandoraLEEAnalyzer(PandoraLEEAnalyzer &&) = delete;
  PandoraLEEAnalyzer &operator=(PandoraLEEAnalyzer const &) = delete;
  PandoraLEEAnalyzer &operator=(PandoraLEEAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const &e) override;
  void endSubRun(const art::SubRun &sr);
  void reconfigure(fhicl::ParameterSet const &pset) override;

private:
  std::string m_hitfinderLabel;
  std::string _geantModuleLabel = "largeant";
  std::string m_pfp_producer;
  std::string m_pid_producer;
  std::string m_calorimetry_producer;

  std::string m_spacepointLabel;
  std::string _mctruthLabel = "generator";
  std::string m_hitmatching_producer;

  lee::ElectronEventSelectionAlg fElectronEventSelectionAlg;
  EnergyHelper energyHelper;
  GeometryHelper geoHelper;
  PandoraInterfaceHelper pandoraHelper;
  uboone::EWTreeUtil ewutil;

  TFile *myTFile;
  TTree *myTTree;
  TTree *myPOTTTree;

  int _interaction_type;

  double m_fidvolXstart;
  double m_fidvolXend;

  double m_fidvolYstart;
  double m_fidvolYend;

  double m_fidvolZstart;
  double m_fidvolZend;
  bool m_useParticleID;
  bool m_isData;
  bool m_isCosmicInTime;
  bool m_printDebug;
  bool m_isOverlaidSample;
  bool m_save_flux_info;
  const int k_cosmic = 1;
  const int k_nu_e = 2;
  const int k_nu_mu = 3;
  const int k_nc = 4;
  const int k_dirt = 5;
  const int k_data = 6;
  const int k_other = 0;
  const int k_mixed = 7;
  std::vector<double> _energy;
  int _true_nu_is_fiducial;
  double _nu_energy;

  int _n_tracks;
  int _n_showers;
  double _vx;
  double _vy;
  double _vz;

  double _true_vx;
  double _true_vy;
  double _true_vz;

  double _true_vx_sce;
  double _true_vy_sce;
  double _true_vz_sce;

  std::vector<double> _true_shower_x_sce;
  std::vector<double> _true_shower_y_sce;
  std::vector<double> _true_shower_z_sce;
  std::vector<int> _true_shower_pdg;
  std::vector<double> _true_shower_depE;
  
  int _nu_matched_tracks;
  int _nu_matched_showers;

  int _nu_pdg;
  int _ccnc;
  int _category;
  int _run;
  int _subrun;
  int _event;
  int _n_candidates;
  int _n_true_nu;
  int _run_sr;
  int _subrun_sr;
  int _n_matched;
  double _pot;
  int _event_passed;
  int _numu_passed;
  int _numu_cuts;
  double _distance;
  double _cosmic_fraction;

  std::vector<int> _flash_passed;
  std::vector<int> _track_passed;
  std::vector<int> _shower_passed;
  std::vector<int> _primary_indexes;
  std::vector<int> _number_tracks;
  std::vector<int> _number_showers;

  std::vector<int> _matched_showers;
  std::vector<int> _matched_tracks;

  std::vector<std::string> _matched_tracks_process;
  std::vector<double> _matched_tracks_energy;

  std::vector<std::string> _matched_showers_process;
  std::vector<double> _matched_showers_energy;

  int _n_primaries;
  int _chosen_candidate;

  double _bnbweight;

  std::vector<std::vector<double>> _shower_dQdx_hits;
  std::vector<std::vector<double>> _shower_dEdx_hits;

  std::vector<std::vector<double>> _shower_dQdx;
  std::vector<std::vector<double>> _shower_dEdx;
  std::vector<std::vector<double>> _shower_dQdx_cali;
  std::vector<std::vector<double>> _shower_dEdx_cali;
  std::vector<std::vector<double>> _shower_pitches;

  std::vector<std::vector<double>> _track_dQdx_hits;
  std::vector<std::vector<double>> _track_dEdx_hits;

  std::vector<std::vector<double>> _track_dQdx;
  std::vector<std::vector<double>> _track_dQdx_cali;

  std::vector<std::vector<double>> _track_dEdx;

  std::vector<size_t> _nu_track_ids;
  std::vector<size_t> _nu_shower_ids;

  std::vector< std::vector<size_t> > _nu_track_daughters;
  std::vector< std::vector<size_t> > _nu_shower_daughters;

  std::vector<double> _shower_open_angle;
  std::vector<double> _shower_length;
  std::vector<double> _shower_dir_x;
  std::vector<double> _shower_dir_y;
  std::vector<double> _shower_dir_z;

  std::vector<double> _shower_start_x;
  std::vector<double> _shower_start_y;
  std::vector<double> _shower_start_z;

  std::vector<double> _shower_theta;
  std::vector<double> _shower_phi;

  std::vector<std::vector<double>> _shower_energy;
  std::vector<std::vector<double>> _shower_energy_cali;
  std::vector<std::vector<double>> _track_energy_cali;

  std::vector<double> _track_dir_x;
  std::vector<double> _track_dir_y;
  std::vector<double> _track_dir_z;
  std::vector<int> _track_is_fiducial;
  std::vector<int> _shower_is_fiducial;

  std::vector<double> _track_res_mean;
  std::vector<double> _track_res_std;

  std::vector<double> _shower_res_mean;
  std::vector<double> _shower_res_std;

  std::vector<double> _track_start_x;
  std::vector<double> _track_start_y;
  std::vector<double> _track_start_z;

  std::vector<double> _track_end_x;
  std::vector<double> _track_end_y;
  std::vector<double> _track_end_z;

  std::vector<double> _track_theta;
  std::vector<double> _track_phi;

  std::vector<double> _track_length;
  std::vector<double> _track_id;

  std::vector<double> _track_bragg_p;
  std::vector<double> _track_bragg_mu;
  std::vector<double> _track_bragg_mip;

  std::vector<double> _track_pidchi;
  std::vector<double> _track_pidchipr;
  std::vector<double> _track_pidchika;
  std::vector<double> _track_pidchipi;
  std::vector<double> _track_pidchimu;
  std::vector<double> _track_pida;

  std::vector<double> _track_energy_dedx;
  std::vector<std::vector<double>> _track_energy_hits;

  std::vector<int> _nu_daughters_pdg;
  std::vector<double> _nu_daughters_E;

  std::vector<double> _nu_daughters_px;
  std::vector<double> _nu_daughters_py;
  std::vector<double> _nu_daughters_pz;

  std::vector<double> _nu_daughters_vx;
  std::vector<double> _nu_daughters_vy;
  std::vector<double> _nu_daughters_vz;

  std::vector<double> _nu_daughters_endx;
  std::vector<double> _nu_daughters_endy;
  std::vector<double> _nu_daughters_endz;

  std::vector<double> _flash_PE;
  std::vector<double> _flash_time;

  std::vector<float> _shower_sp_x;
  std::vector<float> _shower_sp_y;
  std::vector<float> _shower_sp_z;
  std::vector<float> _shower_sp_int;

  double _TPC_x;
  double _flash_x;

  std::vector<std::vector<double>> _shower_pca;
  std::vector<std::vector<double>> _track_pca;

  std::vector<std::vector<int>> _shower_nhits;
  std::vector<std::vector<int>> _track_nhits;

  /*
  * @brief Clears filled variables
  */
  void clear();

  /*
  * @brief Return the longest reconstructed track
  *
  * @param[in] candidates  vector of neutrino candidates indexes
  * @param[in] evt         current art::Event
  *
  * @return            index of the chosen neutrino candidate
  */
  size_t choose_candidate(
    std::vector<size_t> &candidates,
    const art::Event &evt);

  /*
  * @brief Return the longest reconstructed track
  *
  * @param[in] tracks  vector of reconstructed tracks
  *
  * @return            longest reconstructed track object
  */
  art::Ptr<recob::Track> get_longest_track(
    std::vector<art::Ptr<recob::Track>> &tracks);

  /*
  * @brief Return the most energetic reconstructed shower
  *
  * @param[in] showers  vector of reconstructed showers
  *
  * @return             most energetic reconstructed shower object
  */
  art::Ptr<recob::Shower> get_most_energetic_shower(
    std::vector<art::Ptr<recob::Shower>> &showers);

  /*
  * @brief Determines if a PFParticle is matched with a MCParticle coming from
  * a neutrino interaction or a cosmic ray
  *
  * @param[in]  evt               current art Event
  * @param[out] neutrino_pdg      vector of PDG codes for neutrino-matched PFParticles
  * @param[out] neutrino_process  vector of interaction processes for neutrino-matched PFParticles
  * @param[out] neutrino_energy   vector of true energy of neutrino-matched MCParticles
  * @param[out] neutrino_pf       vector of neutrino-matched PFParticles
  * @param[out] cosmic_pdg        vector of PDG codes for cosmic-matched PFParticles
  * @param[out] cosmic_process    vector of interaction processes for cosmic-matched PFParticles
  * @param[out] cosmic_energy     vector of true energy of cosmic-matched MCParticles
  * @param[out] cosmic_pf         vector of cosmic-matched PFParticles
  */
  void categorizePFParticles(
    art::Event const &evt,

    std::vector<int> &neutrino_pdg,
    std::vector<std::string> &neutrino_process,
    std::vector<double> &neutrino_energy,
    std::vector<art::Ptr<recob::PFParticle>> &neutrino_pf,

    std::vector<int> &cosmic_pdg,
    std::vector<std::string> &cosmic_process,
    std::vector<double> &cosmic_energy,
    std::vector<art::Ptr<recob::PFParticle>> &cosmic_pf);

};

}

#endif // PANDORA_LEE_H

