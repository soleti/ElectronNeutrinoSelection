<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ElectronNeutrinoSelection: Lee</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ElectronNeutrinoSelection
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Lee</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlee_1_1ElectronEventSelectionAlg.html">lee::ElectronEventSelectionAlg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlee_1_1EnergyHelper.html">lee::EnergyHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlee_1_1GeometryHelper.html">lee::GeometryHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlee_1_1PandoraInterfaceHelper.html">lee::PandoraInterfaceHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlee_1_1PandoraLEEAnalyzer.html">lee::PandoraLEEAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga70b6dfa1b2176c8ecbee29c567946890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70b6dfa1b2176c8ecbee29c567946890"></a>
typedef std::map&lt; art::Ptr<br class="typebreak"/>
&lt; recob::PFParticle &gt;<br class="typebreak"/>
, art::Ptr&lt; simb::MCParticle &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lar_pandora::PFParticlesToMCParticles</b></td></tr>
<tr class="separator:ga70b6dfa1b2176c8ecbee29c567946890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4126ea41de810a723eb4c1023fb418"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e4126ea41de810a723eb4c1023fb418"></a>
typedef std::map&lt; art::Ptr<br class="typebreak"/>
&lt; recob::PFParticle &gt;<br class="typebreak"/>
, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::RecoParticleToNMatchedHits</b></td></tr>
<tr class="separator:ga1e4126ea41de810a723eb4c1023fb418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad68c1843c146182933b27bf7be0455a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad68c1843c146182933b27bf7be0455a4"></a>
typedef std::map&lt; art::Ptr<br class="typebreak"/>
&lt; simb::MCParticle &gt;<br class="typebreak"/>
, RecoParticleToNMatchedHits &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::ParticleMatchingMap</b></td></tr>
<tr class="separator:gad68c1843c146182933b27bf7be0455a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084ff379386cea31dbc631216b56b9eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga084ff379386cea31dbc631216b56b9eb"></a>
typedef std::set&lt; art::Ptr<br class="typebreak"/>
&lt; recob::PFParticle &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PFParticleSet</b></td></tr>
<tr class="separator:ga084ff379386cea31dbc631216b56b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ec016bd8fc6df09c6f95dba3962bba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1ec016bd8fc6df09c6f95dba3962bba"></a>
typedef std::set&lt; art::Ptr<br class="typebreak"/>
&lt; simb::MCParticle &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::MCParticleSet</b></td></tr>
<tr class="separator:gab1ec016bd8fc6df09c6f95dba3962bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga59666f2bec60817a81fcdd467d9b9641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga59666f2bec60817a81fcdd467d9b9641">lee::ElectronEventSelectionAlg::eventSelected</a> (const art::Event &amp;evt)</td></tr>
<tr class="memdesc:ga59666f2bec60817a81fcdd467d9b9641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Event Selection Function.  <a href="#ga59666f2bec60817a81fcdd467d9b9641">More...</a><br/></td></tr>
<tr class="separator:ga59666f2bec60817a81fcdd467d9b9641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1378ec08aba381d438816c8bc31951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga8f1378ec08aba381d438816c8bc31951">lee::ElectronEventSelectionAlg::reconfigure</a> (fhicl::ParameterSet const &amp;p)</td></tr>
<tr class="memdesc:ga8f1378ec08aba381d438816c8bc31951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure all of the parameters of this class.  <a href="#ga8f1378ec08aba381d438816c8bc31951">More...</a><br/></td></tr>
<tr class="separator:ga8f1378ec08aba381d438816c8bc31951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1853e2053d74627cd4466cf670dc0c31"><td class="memItemLeft" align="right" valign="top">const std::map&lt; size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga1853e2053d74627cd4466cf670dc0c31">lee::ElectronEventSelectionAlg::opticalfilter</a> (const art::Event &amp;evt, const std::vector&lt; size_t &gt; &amp;pfplist, const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt; pfparticle_handle)</td></tr>
<tr class="memdesc:ga1853e2053d74627cd4466cf670dc0c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a flash within the 3.2-4.8 ms window and compatible with the center of charge.  <a href="#ga1853e2053d74627cd4466cf670dc0c31">More...</a><br/></td></tr>
<tr class="separator:ga1853e2053d74627cd4466cf670dc0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d979b26116ec25d26884702d0f9c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga4d8d979b26116ec25d26884702d0f9c6">lee::ElectronEventSelectionAlg::flashBasedSelection</a> (const art::Event &amp;evt, const std::vector&lt; size_t &gt; &amp;pfplist, const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt; pfparticle_handle)</td></tr>
<tr class="memdesc:ga4d8d979b26116ec25d26884702d0f9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a flash within the flash_window_start - flash_window_end window with enough PE. and compatible with the center of charge, the best one is selected using flashmatching.  <a href="#ga4d8d979b26116ec25d26884702d0f9c6">More...</a><br/></td></tr>
<tr class="separator:ga4d8d979b26116ec25d26884702d0f9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06a3e470d9b2ca729d25822fac19e455"><td class="memItemLeft" align="right" valign="top">const flashana::QCluster_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga06a3e470d9b2ca729d25822fac19e455">lee::ElectronEventSelectionAlg::collect3DHits</a> (const art::Event &amp;evt, const std::vector&lt; size_t &gt; &amp;pfplist)</td></tr>
<tr class="memdesc:ga06a3e470d9b2ca729d25822fac19e455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a photon cluster for a neutrino pfp hierarchy PFParticle.  <a href="#ga06a3e470d9b2ca729d25822fac19e455">More...</a><br/></td></tr>
<tr class="separator:ga06a3e470d9b2ca729d25822fac19e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb99143e1546158d3f030724694e6a51"><td class="memItemLeft" align="right" valign="top">TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gafb99143e1546158d3f030724694e6a51">lee::ElectronEventSelectionAlg::spaceChargeTrueToReco</a> (const TVector3 &amp;xyz)</td></tr>
<tr class="memdesc:gafb99143e1546158d3f030724694e6a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the true coordinates corrected by the space-charge effect.  <a href="#gafb99143e1546158d3f030724694e6a51">More...</a><br/></td></tr>
<tr class="separator:gafb99143e1546158d3f030724694e6a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad936812d5e9dc7999a37c75b84b04ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad936812d5e9dc7999a37c75b84b04ada"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gad936812d5e9dc7999a37c75b84b04ada">lee::ElectronEventSelectionAlg::clear</a> ()</td></tr>
<tr class="memdesc:gad936812d5e9dc7999a37c75b84b04ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset internal variables. <br/></td></tr>
<tr class="separator:gad936812d5e9dc7999a37c75b84b04ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317c107f710fc965cd7e062ac933d3df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga317c107f710fc965cd7e062ac933d3df"></a>
const std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga317c107f710fc965cd7e062ac933d3df">lee::ElectronEventSelectionAlg::get_primary_indexes</a> () const </td></tr>
<tr class="memdesc:ga317c107f710fc965cd7e062ac933d3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the selected pfparticle top level neutrino candidate indexes. <br/></td></tr>
<tr class="separator:ga317c107f710fc965cd7e062ac933d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6259851e755db48eb0dd831708212e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6259851e755db48eb0dd831708212e27"></a>
const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga6259851e755db48eb0dd831708212e27">lee::ElectronEventSelectionAlg::get_n_neutrino_candidates</a> () const </td></tr>
<tr class="memdesc:ga6259851e755db48eb0dd831708212e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of neutrino candidates. <br/></td></tr>
<tr class="separator:ga6259851e755db48eb0dd831708212e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34dc2b97e0065b07a5233e3b46b83a4"><td class="memItemLeft" align="right" valign="top">const std::map&lt; size_t, bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gab34dc2b97e0065b07a5233e3b46b83a4">lee::ElectronEventSelectionAlg::get_neutrino_candidate_passed</a> () const </td></tr>
<tr class="memdesc:gab34dc2b97e0065b07a5233e3b46b83a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform whether a particular candidate passed or failed the algorithm.  <a href="#gab34dc2b97e0065b07a5233e3b46b83a4">More...</a><br/></td></tr>
<tr class="separator:gab34dc2b97e0065b07a5233e3b46b83a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffda5b411008752c1355a9dd3a1d9c1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffda5b411008752c1355a9dd3a1d9c1e"></a>
const std::map&lt; size_t, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaffda5b411008752c1355a9dd3a1d9c1e">lee::ElectronEventSelectionAlg::get_op_flash_indexes</a> () const </td></tr>
<tr class="memdesc:gaffda5b411008752c1355a9dd3a1d9c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the flash matched with the pfparticle. <br/></td></tr>
<tr class="separator:gaffda5b411008752c1355a9dd3a1d9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac098d39d04f407c9bfc574da4b82fee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac098d39d04f407c9bfc574da4b82fee6"></a>
const std::map&lt; size_t, <br class="typebreak"/>
TVector3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gac098d39d04f407c9bfc574da4b82fee6">lee::ElectronEventSelectionAlg::get_neutrino_vertex</a> () const </td></tr>
<tr class="memdesc:gac098d39d04f407c9bfc574da4b82fee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pandora calculated vertex indexed by pfparticle id number. <br/></td></tr>
<tr class="separator:gac098d39d04f407c9bfc574da4b82fee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43afa7fb8c10333f89774c6d4ea714dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43afa7fb8c10333f89774c6d4ea714dc"></a>
const std::map&lt; size_t, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga43afa7fb8c10333f89774c6d4ea714dc">lee::ElectronEventSelectionAlg::get_n_showers</a> () const </td></tr>
<tr class="memdesc:ga43afa7fb8c10333f89774c6d4ea714dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of showers for this pfparticle. <br/></td></tr>
<tr class="separator:ga43afa7fb8c10333f89774c6d4ea714dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24d64eca5e56d0550572b24d5e213f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad24d64eca5e56d0550572b24d5e213f7"></a>
const std::map&lt; size_t, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gad24d64eca5e56d0550572b24d5e213f7">lee::ElectronEventSelectionAlg::get_n_tracks</a> () const </td></tr>
<tr class="memdesc:gad24d64eca5e56d0550572b24d5e213f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of tracks for pfparticle index. <br/></td></tr>
<tr class="separator:gad24d64eca5e56d0550572b24d5e213f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea645ce175506b368ceb116bbb77889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ea645ce175506b368ceb116bbb77889"></a>
const std::map&lt; size_t, <br class="typebreak"/>
std::vector&lt; size_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga7ea645ce175506b368ceb116bbb77889">lee::ElectronEventSelectionAlg::get_pfp_id_showers_from_primary</a> () const </td></tr>
<tr class="memdesc:ga7ea645ce175506b368ceb116bbb77889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of pfparticle indexes that are showers that are associated with primary pfparticle indexes. <br/></td></tr>
<tr class="separator:ga7ea645ce175506b368ceb116bbb77889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00266c70e046a9ee27e979be75925a09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00266c70e046a9ee27e979be75925a09"></a>
const std::map&lt; size_t, <br class="typebreak"/>
std::vector&lt; size_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga00266c70e046a9ee27e979be75925a09">lee::ElectronEventSelectionAlg::get_pfp_id_tracks_from_primary</a> () const </td></tr>
<tr class="memdesc:ga00266c70e046a9ee27e979be75925a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of pfparticle indexes that are tracks that are associated with primary pfparticle indexes. <br/></td></tr>
<tr class="separator:ga00266c70e046a9ee27e979be75925a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306e62904f73e727c6f938d2a197f68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga306e62904f73e727c6f938d2a197f68e"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga306e62904f73e727c6f938d2a197f68e">lee::ElectronEventSelectionAlg::get_flash_PE</a> () const </td></tr>
<tr class="memdesc:ga306e62904f73e727c6f938d2a197f68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of total PE of the flashes. <br/></td></tr>
<tr class="separator:ga306e62904f73e727c6f938d2a197f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9990f4a980662e786fc8e38146ce4456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9990f4a980662e786fc8e38146ce4456"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga9990f4a980662e786fc8e38146ce4456">lee::ElectronEventSelectionAlg::get_flash_time</a> () const </td></tr>
<tr class="memdesc:ga9990f4a980662e786fc8e38146ce4456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of times of the flashes. <br/></td></tr>
<tr class="separator:ga9990f4a980662e786fc8e38146ce4456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b697a2eec43de221621bd4aca906e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69b697a2eec43de221621bd4aca906e2"></a>
const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga69b697a2eec43de221621bd4aca906e2">lee::ElectronEventSelectionAlg::get_flash_x</a> () const </td></tr>
<tr class="memdesc:ga69b697a2eec43de221621bd4aca906e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position in x of the flash. <br/></td></tr>
<tr class="separator:ga69b697a2eec43de221621bd4aca906e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c653a5d3225c3e3aa5dc84738ffa086"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c653a5d3225c3e3aa5dc84738ffa086"></a>
const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga2c653a5d3225c3e3aa5dc84738ffa086">lee::ElectronEventSelectionAlg::get_TPC_x</a> () const </td></tr>
<tr class="memdesc:ga2c653a5d3225c3e3aa5dc84738ffa086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position in x of the center of the collected charge. <br/></td></tr>
<tr class="separator:ga2c653a5d3225c3e3aa5dc84738ffa086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4523185d78d6b7aa94dbf26475750282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga4523185d78d6b7aa94dbf26475750282">lee::EnergyHelper::reconfigure</a> (fhicl::ParameterSet const &amp;pset)</td></tr>
<tr class="memdesc:ga4523185d78d6b7aa94dbf26475750282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure all of the parameters of this class.  <a href="#ga4523185d78d6b7aa94dbf26475750282">More...</a><br/></td></tr>
<tr class="separator:ga4523185d78d6b7aa94dbf26475750282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab3ce039f7c08ce5fbb1126a861c36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga3ab3ce039f7c08ce5fbb1126a861c36c">lee::EnergyHelper::dQdx</a> (const recob::Shower *shower_obj, std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *clusters, art::FindManyP&lt; recob::Hit &gt; *hits_per_cluster, std::vector&lt; double &gt; &amp;dqdx, std::vector&lt; double &gt; &amp;dqdx_hits, std::vector&lt; double &gt; &amp;pitches)</td></tr>
<tr class="memdesc:ga3ab3ce039f7c08ce5fbb1126a861c36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the dQdx of a shower.  <a href="#ga3ab3ce039f7c08ce5fbb1126a861c36c">More...</a><br/></td></tr>
<tr class="separator:ga3ab3ce039f7c08ce5fbb1126a861c36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493326200e39f3aaa22999c55c22b6f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga493326200e39f3aaa22999c55c22b6f5">lee::EnergyHelper::PID</a> (const std::vector&lt; art::Ptr&lt; anab::ParticleID &gt;&gt; *pids, int trackID, std::string AlgName, anab::kVariableType VariableType, int pdgCode)</td></tr>
<tr class="memdesc:ga493326200e39f3aaa22999c55c22b6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific ParticleID algorithm for a single track.  <a href="#ga493326200e39f3aaa22999c55c22b6f5">More...</a><br/></td></tr>
<tr class="separator:ga493326200e39f3aaa22999c55c22b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2844c7f27f79fbe5e16d9c674ca4afa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga2844c7f27f79fbe5e16d9c674ca4afa1">lee::EnergyHelper::dEdx_from_dQdx</a> (std::vector&lt; double &gt; &amp;dedx, std::vector&lt; double &gt; dqdx)</td></tr>
<tr class="memdesc:ga2844c7f27f79fbe5e16d9c674ca4afa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert dQ/dx vector into dE/dx vector (in MeV)  <a href="#ga2844c7f27f79fbe5e16d9c674ca4afa1">More...</a><br/></td></tr>
<tr class="separator:ga2844c7f27f79fbe5e16d9c674ca4afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f41d2b1bee9a0f761179f3059f8a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gac5f41d2b1bee9a0f761179f3059f8a49">lee::EnergyHelper::PCA</a> (std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *clusters, art::FindManyP&lt; recob::Hit &gt; *hits_per_cluster, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;pca_planes)</td></tr>
<tr class="memdesc:gac5f41d2b1bee9a0f761179f3059f8a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal Component Analysis of reconstructed clusters.  <a href="#gac5f41d2b1bee9a0f761179f3059f8a49">More...</a><br/></td></tr>
<tr class="separator:gac5f41d2b1bee9a0f761179f3059f8a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf141846d9be1716bcfcf351633bdf8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaf141846d9be1716bcfcf351633bdf8e7">lee::EnergyHelper::get_cali</a> (std::vector&lt; art::Ptr&lt; recob::SpacePoint &gt;&gt; *spcpnts, art::FindManyP&lt; recob::Hit &gt; *hits_per_spcpnts, std::vector&lt; double &gt; &amp;cali_corr)</td></tr>
<tr class="memdesc:gaf141846d9be1716bcfcf351633bdf8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration value for the energy of a reconstructed object.  <a href="#gaf141846d9be1716bcfcf351633bdf8e7">More...</a><br/></td></tr>
<tr class="separator:gaf141846d9be1716bcfcf351633bdf8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbb21a3db419c9580aec4976c5137a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaabbb21a3db419c9580aec4976c5137a9">lee::EnergyHelper::energy_from_hits</a> (std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *clusters, art::FindManyP&lt; recob::Hit &gt; *hits_per_cluster, std::vector&lt; int &gt; &amp;nHits, std::vector&lt; double &gt; &amp;pfenergy)</td></tr>
<tr class="memdesc:gaabbb21a3db419c9580aec4976c5137a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure calorimetric energy for a reconstructed object.  <a href="#gaabbb21a3db419c9580aec4976c5137a9">More...</a><br/></td></tr>
<tr class="separator:gaabbb21a3db419c9580aec4976c5137a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01205d4a5d2f8d5ad0d4d5462e0b7563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga01205d4a5d2f8d5ad0d4d5462e0b7563">lee::EnergyHelper::cluster_residuals</a> (std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *clusters, art::FindManyP&lt; recob::Hit &gt; *hits_per_cluster, double &amp;mean_v, double &amp;std_v)</td></tr>
<tr class="memdesc:ga01205d4a5d2f8d5ad0d4d5462e0b7563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the spatial residuals of the hits in a reconstructed cluster along its direction.  <a href="#ga01205d4a5d2f8d5ad0d4d5462e0b7563">More...</a><br/></td></tr>
<tr class="separator:ga01205d4a5d2f8d5ad0d4d5462e0b7563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cd9ba04f447b9922c56bbb320bce08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga27cd9ba04f447b9922c56bbb320bce08">lee::EnergyHelper::track_dQdx</a> (std::vector&lt; art::Ptr&lt; anab::Calorimetry &gt;&gt; *calos, std::vector&lt; double &gt; &amp;dqdx, std::vector&lt; double &gt; &amp;dedx)</td></tr>
<tr class="memdesc:ga27cd9ba04f447b9922c56bbb320bce08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the dQ/dx and dE/dx of a track using the anab::Calorimetry information.  <a href="#ga27cd9ba04f447b9922c56bbb320bce08">More...</a><br/></td></tr>
<tr class="separator:ga27cd9ba04f447b9922c56bbb320bce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4926738bfba2d91bc187ad8a7db6e997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga4926738bfba2d91bc187ad8a7db6e997">lee::EnergyHelper::dQdx_cali</a> (const recob::Shower *shower_obj, std::vector&lt; double &gt; &amp;dqdx_cali)</td></tr>
<tr class="memdesc:ga4926738bfba2d91bc187ad8a7db6e997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration value for the dQ/dx of a reconstructed shower.  <a href="#ga4926738bfba2d91bc187ad8a7db6e997">More...</a><br/></td></tr>
<tr class="separator:ga4926738bfba2d91bc187ad8a7db6e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4f0303130ac496452b30f60f43f5f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga4d4f0303130ac496452b30f60f43f5f1">lee::GeometryHelper::isInside</a> (std::vector&lt; double &gt; P, std::vector&lt; std::vector&lt; double &gt; &gt; V)</td></tr>
<tr class="memdesc:ga4d4f0303130ac496452b30f60f43f5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a point is within a rectangle (in 2D)  <a href="#ga4d4f0303130ac496452b30f60f43f5f1">More...</a><br/></td></tr>
<tr class="separator:ga4d4f0303130ac496452b30f60f43f5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d02792fc6869b86d850077460536b2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga6d02792fc6869b86d850077460536b2a">lee::GeometryHelper::isFiducial</a> (const std::vector&lt; double &gt; &amp;x) const </td></tr>
<tr class="memdesc:ga6d02792fc6869b86d850077460536b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified point is in the fiducial volume.  <a href="#ga6d02792fc6869b86d850077460536b2a">More...</a><br/></td></tr>
<tr class="separator:ga6d02792fc6869b86d850077460536b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5383a8e03c66e9506a75d9afc41f5ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga5383a8e03c66e9506a75d9afc41f5ff0">lee::GeometryHelper::isFiducial</a> (const TVector3 &amp;x) const </td></tr>
<tr class="memdesc:ga5383a8e03c66e9506a75d9afc41f5ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified point is in the fiducial volume.  <a href="#ga5383a8e03c66e9506a75d9afc41f5ff0">More...</a><br/></td></tr>
<tr class="separator:ga5383a8e03c66e9506a75d9afc41f5ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10d0ef387b7573c6cc12565d5bfd0e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gae10d0ef387b7573c6cc12565d5bfd0e1">lee::GeometryHelper::isFiducial</a> (const double x[3]) const </td></tr>
<tr class="memdesc:gae10d0ef387b7573c6cc12565d5bfd0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified point is in the fiducial volume Not recommended, no array size checking is done.  <a href="#gae10d0ef387b7573c6cc12565d5bfd0e1">More...</a><br/></td></tr>
<tr class="separator:gae10d0ef387b7573c6cc12565d5bfd0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa423d79bbb62bdd3337f1d965023baa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaaa423d79bbb62bdd3337f1d965023baa">lee::GeometryHelper::isActive</a> (const std::vector&lt; double &gt; &amp;x) const </td></tr>
<tr class="memdesc:gaaa423d79bbb62bdd3337f1d965023baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified point is in the active volume.  <a href="#gaaa423d79bbb62bdd3337f1d965023baa">More...</a><br/></td></tr>
<tr class="separator:gaaa423d79bbb62bdd3337f1d965023baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c3e840d748f5c5340315b6c096e7c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gab5c3e840d748f5c5340315b6c096e7c8">lee::GeometryHelper::isActive</a> (const double x[3]) const </td></tr>
<tr class="memdesc:gab5c3e840d748f5c5340315b6c096e7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified point is in the active volume Not recommended, no array size checking is done.  <a href="#gab5c3e840d748f5c5340315b6c096e7c8">More...</a><br/></td></tr>
<tr class="separator:gab5c3e840d748f5c5340315b6c096e7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15984c2f8c26a4bb9578835bedd19537"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga15984c2f8c26a4bb9578835bedd19537">lee::GeometryHelper::distance</a> (const std::vector&lt; double &gt; &amp;a, const std::vector&lt; double &gt; &amp;b) const </td></tr>
<tr class="memdesc:ga15984c2f8c26a4bb9578835bedd19537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D distance between two points.  <a href="#ga15984c2f8c26a4bb9578835bedd19537">More...</a><br/></td></tr>
<tr class="separator:ga15984c2f8c26a4bb9578835bedd19537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ad8eed3b9842a114cce96c73fb02e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga481ad8eed3b9842a114cce96c73fb02e">lee::GeometryHelper::distance</a> (const TVector3 &amp;a, const TVector3 &amp;b) const </td></tr>
<tr class="memdesc:ga481ad8eed3b9842a114cce96c73fb02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 3D distance between two points.  <a href="#ga481ad8eed3b9842a114cce96c73fb02e">More...</a><br/></td></tr>
<tr class="separator:ga481ad8eed3b9842a114cce96c73fb02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f688ef51442c37a5440d45cfad799f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga02f688ef51442c37a5440d45cfad799f">lee::GeometryHelper::getPitch</a> (const TVector3 &amp;direction, const int &amp;pl) const </td></tr>
<tr class="memdesc:ga02f688ef51442c37a5440d45cfad799f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D effective pitch give a direction and a plane.  <a href="#ga02f688ef51442c37a5440d45cfad799f">More...</a><br/></td></tr>
<tr class="separator:ga02f688ef51442c37a5440d45cfad799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b67d6d907f9fca0e16ccd9dba85eb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga5b67d6d907f9fca0e16ccd9dba85eb54">lee::GeometryHelper::setFiducialVolumeCuts</a> (float m_fidvolXstart, float m_fidvolXend, float m_fidvolYstart, float m_fidvolYend, float m_fidvolZstart, float m_fidvolZend)</td></tr>
<tr class="memdesc:ga5b67d6d907f9fca0e16ccd9dba85eb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fiducial volume cuts.  <a href="#ga5b67d6d907f9fca0e16ccd9dba85eb54">More...</a><br/></td></tr>
<tr class="separator:ga5b67d6d907f9fca0e16ccd9dba85eb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a7546e5a4c1693a9366126ac6c63ba9"><td class="memItemLeft" align="right" valign="top">TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga1a7546e5a4c1693a9366126ac6c63ba9">lee::GeometryHelper::getAveragePosition</a> (std::vector&lt; art::Ptr&lt; recob::SpacePoint &gt;&gt; &amp;spcpnts)</td></tr>
<tr class="memdesc:ga1a7546e5a4c1693a9366126ac6c63ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average position of a set of space points.  <a href="#ga1a7546e5a4c1693a9366126ac6c63ba9">More...</a><br/></td></tr>
<tr class="separator:ga1a7546e5a4c1693a9366126ac6c63ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403b726646563c7fa8bce4c316226e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga403b726646563c7fa8bce4c316226e15">lee::GeometryHelper::buildRectangle</a> (double length, double width, std::vector&lt; double &gt; &amp;start, std::vector&lt; double &gt; &amp;axis, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;points)</td></tr>
<tr class="memdesc:ga403b726646563c7fa8bce4c316226e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a rectangle.  <a href="#ga403b726646563c7fa8bce4c316226e15">More...</a><br/></td></tr>
<tr class="separator:ga403b726646563c7fa8bce4c316226e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3e6eecea4f75ea9eea31e520b4f0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga5f3e6eecea4f75ea9eea31e520b4f0bc">lee::PandoraInterfaceHelper::traversePFParticleTree</a> (const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt; pfparticles, size_t top_index, std::vector&lt; size_t &gt; &amp;unordered_daugthers, std::string _pfp_producer)</td></tr>
<tr class="memdesc:ga5f3e6eecea4f75ea9eea31e520b4f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Travers the tree of the daughters of a PFParticle.  <a href="#ga5f3e6eecea4f75ea9eea31e520b4f0bc">More...</a><br/></td></tr>
<tr class="separator:ga5f3e6eecea4f75ea9eea31e520b4f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367b3ad86924343d3ab54fa8c84091af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga367b3ad86924343d3ab54fa8c84091af">lee::PandoraInterfaceHelper::calculateChargeCenter</a> (size_t ipf, const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt; pfparticles, const art::Event &amp;evt, std::string _pfp_producer)</td></tr>
<tr class="memdesc:ga367b3ad86924343d3ab54fa8c84091af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the three-dimensional center of the deposited charge for a PFParticle.  <a href="#ga367b3ad86924343d3ab54fa8c84091af">More...</a><br/></td></tr>
<tr class="separator:ga367b3ad86924343d3ab54fa8c84091af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30273cdf4f136187b522c237e61b864e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga30273cdf4f136187b522c237e61b864e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraInterfaceHelper::get_daughter_tracks</b> (std::vector&lt; size_t &gt; pf_ids, const art::Event &amp;evt, std::vector&lt; art::Ptr&lt; recob::Track &gt;&gt; &amp;tracks, std::string _pfp_producer)</td></tr>
<tr class="separator:ga30273cdf4f136187b522c237e61b864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2219037e4e0677d9aeb55e9615b19131"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2219037e4e0677d9aeb55e9615b19131"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraInterfaceHelper::get_daughter_showers</b> (std::vector&lt; size_t &gt; pf_ids, const art::Event &amp;evt, std::vector&lt; art::Ptr&lt; recob::Shower &gt;&gt; &amp;showers, std::string _pfp_producer)</td></tr>
<tr class="separator:ga2219037e4e0677d9aeb55e9615b19131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedec8759b64e578d4d27e4dd57bc2111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaedec8759b64e578d4d27e4dd57bc2111">lee::PandoraInterfaceHelper::GetRecoToTrueMatches</a> (lar_pandora::PFParticlesToMCParticles &amp;matchedParticles)</td></tr>
<tr class="memdesc:gaedec8759b64e578d4d27e4dd57bc2111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure function parameters.  <a href="#gaedec8759b64e578d4d27e4dd57bc2111">More...</a><br/></td></tr>
<tr class="separator:gaedec8759b64e578d4d27e4dd57bc2111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea920f6926b69221a6a04d17e38cbf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacea920f6926b69221a6a04d17e38cbf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraInterfaceHelper::Configure</b> (art::Event const &amp;e, std::string _pfp_producer, std::string _spacepoint_producer, std::string _hitfinder_producer, std::string _geant_producer, std::string _hit_mcp_producer)</td></tr>
<tr class="separator:gacea920f6926b69221a6a04d17e38cbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1841058478f2ef51067eeb588d1711"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab1841058478f2ef51067eeb588d1711"></a>
art::Ptr&lt; simb::MCTruth &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraInterfaceHelper::TrackIDToMCTruth</b> (art::Event const &amp;e, std::string _geant_producer, int geant_track_id)</td></tr>
<tr class="separator:gaab1841058478f2ef51067eeb588d1711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3783391baff0585de9261a559a8d28ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3783391baff0585de9261a559a8d28ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::PandoraLEEAnalyzer</b> (fhicl::ParameterSet const &amp;pset)</td></tr>
<tr class="separator:ga3783391baff0585de9261a559a8d28ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f8e3ecdc7892d554c68080645af88c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50f8e3ecdc7892d554c68080645af88c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::PandoraLEEAnalyzer</b> (<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> const &amp;)=delete</td></tr>
<tr class="separator:ga50f8e3ecdc7892d554c68080645af88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9dc3f96fcb2881bee2bfb46dcedaaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e9dc3f96fcb2881bee2bfb46dcedaaf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::PandoraLEEAnalyzer</b> (<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ga8e9dc3f96fcb2881bee2bfb46dcedaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71d8ba45ecaaa09a587ecf3cd693675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae71d8ba45ecaaa09a587ecf3cd693675"></a>
<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::operator=</b> (<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> const &amp;)=delete</td></tr>
<tr class="separator:gae71d8ba45ecaaa09a587ecf3cd693675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79984f454c76dbb927254731d85e40c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79984f454c76dbb927254731d85e40c4"></a>
<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::operator=</b> (<a class="el" href="classPandoraLEEAnalyzer.html">PandoraLEEAnalyzer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ga79984f454c76dbb927254731d85e40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6142fdaa2037d01df2304cbb17d59b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gab6142fdaa2037d01df2304cbb17d59b0">lee::PandoraLEEAnalyzer::analyze</a> (art::Event const &amp;e) override</td></tr>
<tr class="memdesc:gab6142fdaa2037d01df2304cbb17d59b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main analyzer method, runs for every event in the file.  <a href="#gab6142fdaa2037d01df2304cbb17d59b0">More...</a><br/></td></tr>
<tr class="separator:gab6142fdaa2037d01df2304cbb17d59b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede981b7ff7b78309f2457c40581ba71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gaede981b7ff7b78309f2457c40581ba71">lee::PandoraLEEAnalyzer::endSubRun</a> (const art::SubRun &amp;sr)</td></tr>
<tr class="memdesc:gaede981b7ff7b78309f2457c40581ba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method called at the end of each subrun, it stores the number of POT.  <a href="#gaede981b7ff7b78309f2457c40581ba71">More...</a><br/></td></tr>
<tr class="separator:gaede981b7ff7b78309f2457c40581ba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4696139a07194b86735e93fe0d9df45e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga4696139a07194b86735e93fe0d9df45e">lee::PandoraLEEAnalyzer::reconfigure</a> (fhicl::ParameterSet const &amp;pset) override</td></tr>
<tr class="memdesc:ga4696139a07194b86735e93fe0d9df45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the values of the FHICL file.  <a href="#ga4696139a07194b86735e93fe0d9df45e">More...</a><br/></td></tr>
<tr class="separator:ga4696139a07194b86735e93fe0d9df45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8072bae8c7e78701c093070d17c992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d8072bae8c7e78701c093070d17c992"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga9d8072bae8c7e78701c093070d17c992">lee::PandoraLEEAnalyzer::clear</a> ()</td></tr>
<tr class="memdesc:ga9d8072bae8c7e78701c093070d17c992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears filled variables. <br/></td></tr>
<tr class="separator:ga9d8072bae8c7e78701c093070d17c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2598c705e4307eed73e1989613028ced"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#ga2598c705e4307eed73e1989613028ced">lee::PandoraLEEAnalyzer::choose_candidate</a> (std::vector&lt; size_t &gt; &amp;candidates, const art::Event &amp;evt)</td></tr>
<tr class="memdesc:ga2598c705e4307eed73e1989613028ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest reconstructed track.  <a href="#ga2598c705e4307eed73e1989613028ced">More...</a><br/></td></tr>
<tr class="separator:ga2598c705e4307eed73e1989613028ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76ba045ee298f69ff19ab86be51a69e"><td class="memItemLeft" align="right" valign="top">art::Ptr&lt; recob::Track &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gae76ba045ee298f69ff19ab86be51a69e">lee::PandoraLEEAnalyzer::get_longest_track</a> (std::vector&lt; art::Ptr&lt; recob::Track &gt;&gt; &amp;tracks)</td></tr>
<tr class="memdesc:gae76ba045ee298f69ff19ab86be51a69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest reconstructed track.  <a href="#gae76ba045ee298f69ff19ab86be51a69e">More...</a><br/></td></tr>
<tr class="separator:gae76ba045ee298f69ff19ab86be51a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6eb7dd67f871231011dbfae2dcf6cfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6eb7dd67f871231011dbfae2dcf6cfc"></a>
art::Ptr&lt; recob::Shower &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lee::PandoraLEEAnalyzer::get_most_energetic_shower</b> (std::vector&lt; art::Ptr&lt; recob::Shower &gt;&gt; &amp;showers)</td></tr>
<tr class="separator:gaf6eb7dd67f871231011dbfae2dcf6cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e0369a28fcbca90d62624f59d44aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gae0e0369a28fcbca90d62624f59d44aaa">lee::PandoraLEEAnalyzer::categorizePFParticles</a> (art::Event const &amp;evt, std::vector&lt; int &gt; &amp;neutrino_pdg, std::vector&lt; std::string &gt; &amp;neutrino_process, std::vector&lt; double &gt; &amp;neutrino_energy, std::vector&lt; art::Ptr&lt; recob::PFParticle &gt;&gt; &amp;neutrino_pf, std::vector&lt; int &gt; &amp;cosmic_pdg, std::vector&lt; std::string &gt; &amp;cosmic_process, std::vector&lt; double &gt; &amp;cosmic_energy, std::vector&lt; art::Ptr&lt; recob::PFParticle &gt;&gt; &amp;cosmic_pf)</td></tr>
<tr class="memdesc:gae0e0369a28fcbca90d62624f59d44aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a PFParticle is matched with a MCParticle coming from a neutrino interaction or a cosmic ray.  <a href="#gae0e0369a28fcbca90d62624f59d44aaa">More...</a><br/></td></tr>
<tr class="separator:gae0e0369a28fcbca90d62624f59d44aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadd430a976fa40632e14eb1688cdd785b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd430a976fa40632e14eb1688cdd785b"></a>
lar_pandora::HitsToMCParticles&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gadd430a976fa40632e14eb1688cdd785b">lee::PandoraInterfaceHelper::_hit_to_mcps_map</a></td></tr>
<tr class="memdesc:gadd430a976fa40632e14eb1688cdd785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from recon hits to MCParticles. <br/></td></tr>
<tr class="separator:gadd430a976fa40632e14eb1688cdd785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19df94cb2c29dc2735bf7436c5ccf63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae19df94cb2c29dc2735bf7436c5ccf63"></a>
lar_pandora::PFParticlesToHits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lee.html#gae19df94cb2c29dc2735bf7436c5ccf63">lee::PandoraInterfaceHelper::_pfp_to_hits_map</a></td></tr>
<tr class="memdesc:gae19df94cb2c29dc2735bf7436c5ccf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from PFParticles to recon hits. <br/></td></tr>
<tr class="separator:gae19df94cb2c29dc2735bf7436c5ccf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab6142fdaa2037d01df2304cbb17d59b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraLEEAnalyzer::analyze </td>
          <td>(</td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main analyzer method, runs for every event in the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evt</td><td>current art::Event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga403b726646563c7fa8bce4c316226e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GeometryHelper::buildRectangle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>The start </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">axis</td><td>The axis </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">points</td><td>The points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga367b3ad86924343d3ab54fa8c84091af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; PandoraInterfaceHelper::calculateChargeCenter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ipf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt;&#160;</td>
          <td class="paramname"><em>pfparticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_pfp_producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the three-dimensional center of the deposited charge for a PFParticle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipf</td><td>Index of the PFParticle </td></tr>
    <tr><td class="paramname">pfparticles</td><td>PFParticles handle </td></tr>
    <tr><td class="paramname">evt</td><td>art Event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with: lowest x_sps, center in y, z, and total deposited charge on the collection plane. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0e0369a28fcbca90d62624f59d44aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraLEEAnalyzer::categorizePFParticles </td>
          <td>(</td>
          <td class="paramtype">art::Event const &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neutrino_pdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>neutrino_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>neutrino_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::PFParticle &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neutrino_pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cosmic_pdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cosmic_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cosmic_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::PFParticle &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cosmic_pf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a PFParticle is matched with a MCParticle coming from a neutrino interaction or a cosmic ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evt</td><td>current art Event </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neutrino_pdg</td><td>vector of PDG codes for neutrino-matched PFParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neutrino_process</td><td>vector of interaction processes for neutrino-matched PFParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neutrino_energy</td><td>vector of true energy of neutrino-matched MCParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neutrino_pf</td><td>vector of neutrino-matched PFParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosmic_pdg</td><td>vector of PDG codes for cosmic-matched PFParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosmic_process</td><td>vector of interaction processes for cosmic-matched PFParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosmic_energy</td><td>vector of true energy of cosmic-matched MCParticles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cosmic_pf</td><td>vector of cosmic-matched PFParticles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2598c705e4307eed73e1989613028ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PandoraLEEAnalyzer::choose_candidate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest reconstructed track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">candidates</td><td>vector of neutrino candidates indexes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evt</td><td>current art::Event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the chosen neutrino candidate </dd></dl>

</div>
</div>
<a class="anchor" id="ga01205d4a5d2f8d5ad0d4d5462e0b7563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::cluster_residuals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::FindManyP&lt; recob::Hit &gt; *&#160;</td>
          <td class="paramname"><em>hits_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>std_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the spatial residuals of the hits in a reconstructed cluster along its direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to the vector of reconstructed clusters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hits_per_cluster</td><td>Pointer to the hits-cluster association </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean_v</td><td>Address of the mean value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">std_v</td><td>Address of the standard deviation value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06a3e470d9b2ca729d25822fac19e455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const flashana::QCluster_t ElectronEventSelectionAlg::collect3DHits </td>
          <td>(</td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pfplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a photon cluster for a neutrino pfp hierarchy PFParticle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>art Event </td></tr>
    <tr><td class="paramname">pfplist</td><td>list of pfp indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flashana::QCluster_t object containing the photons </dd></dl>

</div>
</div>
<a class="anchor" id="ga2844c7f27f79fbe5e16d9c674ca4afa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::dEdx_from_dQdx </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dedx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>dqdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert dQ/dx vector into dE/dx vector (in MeV) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dedx</td><td>Address of the dE/dx vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dqdx</td><td>dQ/dx vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15984c2f8c26a4bb9578835bedd19537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GeometryHelper::distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 3D distance between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First Point </td></tr>
    <tr><td class="paramname">b</td><td>Second Point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns SQRT( (a.x - b.x)^2 + (a.y - b.y)^2 + (a.z - b.z)^2 ) </dd></dl>

</div>
</div>
<a class="anchor" id="ga481ad8eed3b9842a114cce96c73fb02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GeometryHelper::distance </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 3D distance between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First Point </td></tr>
    <tr><td class="paramname">b</td><td>Second Point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns SQRT( (a.x - b.x)^2 + (a.y - b.y)^2 + (a.z - b.z)^2 ) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ab3ce039f7c08ce5fbb1126a861c36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::dQdx </td>
          <td>(</td>
          <td class="paramtype">const recob::Shower *&#160;</td>
          <td class="paramname"><em>shower_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::FindManyP&lt; recob::Hit &gt; *&#160;</td>
          <td class="paramname"><em>hits_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dqdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dqdx_hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pitches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the dQdx of a shower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shower_obj</td><td>Pointer to the shower object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to the cluster associated tot the shower </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hits_per_cluster</td><td>Pointer to the hits-cluster association </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dqdx</td><td>Vector of the dQ/dx median values per plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dqdx_hits</td><td>Vector of the dQ/dx hits values per plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pitches</td><td>Vector of the pitches per plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4926738bfba2d91bc187ad8a7db6e997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::dQdx_cali </td>
          <td>(</td>
          <td class="paramtype">const recob::Shower *&#160;</td>
          <td class="paramname"><em>shower_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dqdx_cali</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibration value for the dQ/dx of a reconstructed shower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shower_obj</td><td>Pointer to the reconstructed shower </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dqdx_cali</td><td>Address of the vector of with the dQ/dx calibration values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaede981b7ff7b78309f2457c40581ba71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraLEEAnalyzer::endSubRun </td>
          <td>(</td>
          <td class="paramtype">const art::SubRun &amp;&#160;</td>
          <td class="paramname"><em>sr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method called at the end of each subrun, it stores the number of POT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sr</td><td>current art::SubRun </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaabbb21a3db419c9580aec4976c5137a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::energy_from_hits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::FindManyP&lt; recob::Hit &gt; *&#160;</td>
          <td class="paramname"><em>hits_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pfenergy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure calorimetric energy for a reconstructed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to the vector of reconstructed clusters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hits_per_cluster</td><td>Pointer to the hits-cluster association </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nHits</td><td>Address of the vector of the number of hits per plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pfenergy</td><td>Address of the vector of reconstructed energy per plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59666f2bec60817a81fcdd467d9b9641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ElectronEventSelectionAlg::eventSelected </td>
          <td>(</td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Event Selection Function. </p>
<p>Decides whether or not this event is an electron neutrino candidate</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evt</td><td>art::Event containing the information for this event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or False. True == event passed cuts, false == event failed cuts </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d8d979b26116ec25d26884702d0f9c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; size_t, int &gt; ElectronEventSelectionAlg::flashBasedSelection </td>
          <td>(</td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pfplist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt;&#160;</td>
          <td class="paramname"><em>pfparticle_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there is a flash within the flash_window_start - flash_window_end window with enough PE. and compatible with the center of charge, the best one is selected using flashmatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;size_t&gt;</td><td>pfplist : list of primary neutrino candidates that need to be tested </td></tr>
    <tr><td class="paramname">evt</td><td>art Event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if not passed, otherwise index of the flash is returned </dd></dl>

</div>
</div>
<a class="anchor" id="gaf141846d9be1716bcfcf351633bdf8e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::get_cali </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::SpacePoint &gt;&gt; *&#160;</td>
          <td class="paramname"><em>spcpnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::FindManyP&lt; recob::Hit &gt; *&#160;</td>
          <td class="paramname"><em>hits_per_spcpnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cali_corr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibration value for the energy of a reconstructed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spcpnts</td><td>Pointer to the vector of reconstructed space-points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hits_per_spcpnts</td><td>Pointer to the hits-spacepoints association </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cali_corr</td><td>Address of the two-dimensional vector storing calibration values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae76ba045ee298f69ff19ab86be51a69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">art::Ptr&lt; recob::Track &gt; PandoraLEEAnalyzer::get_longest_track </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::Track &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tracks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the longest reconstructed track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tracks</td><td>vector of reconstructed tracks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>longest reconstructed track object </dd></dl>

</div>
</div>
<a class="anchor" id="gab34dc2b97e0065b07a5233e3b46b83a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;size_t, bool&gt;&amp; lee::ElectronEventSelectionAlg::get_neutrino_candidate_passed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inform whether a particular candidate passed or failed the algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of bool, one-to-one with get_primary_indexes </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a7546e5a4c1693a9366126ac6c63ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TVector3 GeometryHelper::getAveragePosition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::SpacePoint &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spcpnts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average position of a set of space points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spcpnts</td><td>The spcpnts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3D Vector </dd></dl>

</div>
</div>
<a class="anchor" id="ga02f688ef51442c37a5440d45cfad799f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GeometryHelper::getPitch </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3D effective pitch give a direction and a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>The direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pl</td><td>Plane of interest (0, 1, 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedec8759b64e578d4d27e4dd57bc2111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraInterfaceHelper::GetRecoToTrueMatches </td>
          <td>(</td>
          <td class="paramtype">lar_pandora::PFParticlesToMCParticles &amp;&#160;</td>
          <td class="paramname"><em>matchedParticles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure function parameters. </p>
<p>Configure function parameters (call this function first)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the art::Event </td></tr>
    <tr><td class="paramname">_pfp_producer</td><td>the PFParticle producer label </td></tr>
    <tr><td class="paramname">_spacepoint_producer</td><td>the SpacePoint producer label </td></tr>
    <tr><td class="paramname">_hitfinder_producer</td><td>the Hit producer label </td></tr>
    <tr><td class="paramname">_geant_producer</td><td>The Geant4 producer label Returns matching between true and reconstructed particles</td></tr>
    <tr><td class="paramname">matchedParticles</td><td>the output matches between reconstructed and true particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa423d79bbb62bdd3337f1d965023baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isActive </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified point is in the active volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>array of 3D location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>

</div>
</div>
<a class="anchor" id="gab5c3e840d748f5c5340315b6c096e7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isActive </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[3]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified point is in the active volume Not recommended, no array size checking is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>array of 3D location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d02792fc6869b86d850077460536b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isFiducial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified point is in the fiducial volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>vector of length 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga5383a8e03c66e9506a75d9afc41f5ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isFiducial </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified point is in the fiducial volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>TVector3 of 3D location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>

</div>
</div>
<a class="anchor" id="gae10d0ef387b7573c6cc12565d5bfd0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isFiducial </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>[3]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified point is in the fiducial volume Not recommended, no array size checking is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>array of 3D location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d4f0303130ac496452b30f60f43f5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GeometryHelper::isInside </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a point is within a rectangle (in 2D) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>vector containing the point's coordinates </td></tr>
    <tr><td class="paramname">V</td><td>vector of vectors containing rectangle's vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the points is inside, False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga1853e2053d74627cd4466cf670dc0c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; size_t, int &gt; ElectronEventSelectionAlg::opticalfilter </td>
          <td>(</td>
          <td class="paramtype">const art::Event &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pfplist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt;&#160;</td>
          <td class="paramname"><em>pfparticle_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there is a flash within the 3.2-4.8 ms window and compatible with the center of charge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;size_t&gt;</td><td>pfplist : list of primary neutrino candidates that need to be tested </td></tr>
    <tr><td class="paramname">evt</td><td>art Event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if not passed, otherwise index of the flash </dd></dl>

</div>
</div>
<a class="anchor" id="gac5f41d2b1bee9a0f761179f3059f8a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::PCA </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; recob::Cluster &gt;&gt; *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">art::FindManyP&lt; recob::Hit &gt; *&#160;</td>
          <td class="paramname"><em>hits_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pca_planes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Principal Component Analysis of reconstructed clusters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to the vector of reconstructed clusters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hits_pre_cluster</td><td>Pointer to the hits-cluster association </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pca_planes</td><td>Address of the two-dimensional vector storing the PCA eigenvalues per plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga493326200e39f3aaa22999c55c22b6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EnergyHelper::PID </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; art::Ptr&lt; anab::ParticleID &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trackID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>AlgName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">anab::kVariableType&#160;</td>
          <td class="paramname"><em>VariableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pdgCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific ParticleID algorithm for a single track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pids</td><td>Pointer to the vector of ParticleID objects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trackID</td><td>TrackID value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AlgName</td><td>Name of the algorithm (e.g. Bragg peak, PIDA, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableType</td><td>Type of variable (e.g. likelihood) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdgCode</td><td>Assumed PDG code of the track</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of VariableType for the ParticleID AlgName algorithm, given its hypothetical PDG code </dd></dl>

</div>
</div>
<a class="anchor" id="ga4523185d78d6b7aa94dbf26475750282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::reconfigure </td>
          <td>(</td>
          <td class="paramtype">fhicl::ParameterSet const &amp;&#160;</td>
          <td class="paramname"><em>pset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure all of the parameters of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>fcl parameter set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f1378ec08aba381d438816c8bc31951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ElectronEventSelectionAlg::reconfigure </td>
          <td>(</td>
          <td class="paramtype">fhicl::ParameterSet const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure all of the parameters of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>fcl parameter set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4696139a07194b86735e93fe0d9df45e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraLEEAnalyzer::reconfigure </td>
          <td>(</td>
          <td class="paramtype">fhicl::ParameterSet const &amp;&#160;</td>
          <td class="paramname"><em>pset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the values of the FHICL file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pset</td><td>set of FHICL parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b67d6d907f9fca0e16ccd9dba85eb54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GeometryHelper::setFiducialVolumeCuts </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolXstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolXend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolYstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolYend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolZstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_fidvolZend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fiducial volume cuts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolXstart</td><td>The x start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolXend</td><td>The x end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolYstart</td><td>The y start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolYend</td><td>The y end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolZstart</td><td>The z start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m_fidvolZend</td><td>The z end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb99143e1546158d3f030724694e6a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TVector3 ElectronEventSelectionAlg::spaceChargeTrueToReco </td>
          <td>(</td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the true coordinates corrected by the space-charge effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xyz</td><td>TVector3 of the true position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TVector3 of the space-charge corrected position </dd></dl>

</div>
</div>
<a class="anchor" id="ga27cd9ba04f447b9922c56bbb320bce08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnergyHelper::track_dQdx </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; art::Ptr&lt; anab::Calorimetry &gt;&gt; *&#160;</td>
          <td class="paramname"><em>calos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dqdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dedx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the dQ/dx and dE/dx of a track using the anab::Calorimetry information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">calos</td><td>Pointer to the vector of the calorimetry objects </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dqdx</td><td>Address of the vector of the dQ/dx values per plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dedx</td><td>Address of the vector of the dE/dx values per plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f3e6eecea4f75ea9eea31e520b4f0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PandoraInterfaceHelper::traversePFParticleTree </td>
          <td>(</td>
          <td class="paramtype">const art::ValidHandle&lt; std::vector&lt; recob::PFParticle &gt;&gt;&#160;</td>
          <td class="paramname"><em>pfparticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>top_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>unordered_daugthers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_pfp_producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Travers the tree of the daughters of a PFParticle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfparticles</td><td>PFParticles handle </td></tr>
    <tr><td class="paramname">top_index</td><td>Index of the parent </td></tr>
    <tr><td class="paramname">unordered_daugthers</td><td>Vector of PFParticles daughters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
